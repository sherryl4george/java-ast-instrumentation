<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>readme.md</title>
  <link rel="stylesheet" href="https://stackedit.io/style.css" />
</head>

<body class="stackedit">
  <div class="stackedit__left">
    <div class="stackedit__toc">
      
<ul>
<li><a href="#cs474---course-project">CS474 - Course Project</a>
<ul>
<li><a href="#overview">Overview</a></li>
<li><a href="#prerequisites">Prerequisites</a></li>
<li><a href="#dependencies">Dependencies</a></li>
<li><a href="#how-to-run">How to run</a></li>
<li><a href="#technical-design">Technical Design</a></li>
<li><a href="#components-overview">Components Overview</a>
<ul>
<li></li>
</ul>
</li>
<li><a href="#component-details">Component Details</a>
<ul>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>

    </div>
  </div>
  <div class="stackedit__right">
    <div class="stackedit__html">
      <h1 id="cs474---course-project">CS474 - Course Project</h1>
<p>Team members</p>
<ol>
<li>Maithreyi Rajagopalan</li>
<li>Sherryl Mathew George</li>
</ol>
<h2 id="overview">Overview</h2>
<p>The requirements of this project are:</p>
<ol>
<li>An instrumentation program that takes syntactically correct source code of some Java application and using the Eclipse Java Abstract Syntax Tree (AST) parser parse this application into an AST</li>
<li>For each expression and statement in each scope, the program will insert an instrumenting statement to capture the values of the variables.</li>
<li>Once the application is instrumented, it will be compiled and run using a build script</li>
<li>Once instrumented and compiled, the rogram will run multiple instances of the instrumented application with different input values by starting the JVM. The trace information from the executing Java application is send to the launcher program where a hashtable is used to keep track of the variables, their bindings and values at different points of the program execution.</li>
</ol>
<h2 id="prerequisites">Prerequisites</h2>
<ol>
<li>JAVA SDK 11 or higher</li>
<li>Scala 2.13 or above</li>
</ol>
<p><strong>Note:</strong> The project is developed and tested on a Unix based OS.</p>
<h2 id="dependencies">Dependencies</h2>

<table>
<thead>
<tr>
<th>Library</th>
<th>Version</th>
</tr>
</thead>
<tbody>
<tr>
<td>config</td>
<td>v1.3.4</td>
</tr>
<tr>
<td>logback-classic</td>
<td>v1.2.3</td>
</tr>
<tr>
<td>scala-logging</td>
<td>v3.9.2</td>
</tr>
<tr>
<td>logback-config</td>
<td>v0.4.0</td>
</tr>
<tr>
<td>scalatest</td>
<td>v3.0.8</td>
</tr>
<tr>
<td>org.eclipse.jdt.core</td>
<td>v3.19.0</td>
</tr>
<tr>
<td>commons-io</td>
<td>v2.6</td>
</tr>
<tr>
<td>ant</td>
<td>v1.10.7</td>
</tr>
<tr>
<td>akka-http</td>
<td>v10.1.10</td>
</tr>
<tr>
<td>akka-stream</td>
<td>v2.6.0</td>
</tr>
<tr>
<td>play-json</td>
<td>v2.8.0</td>
</tr>
</tbody>
</table><h2 id="how-to-run">How to run</h2>
<p>The project has two main files:</p>
<ol>
<li>ServerLaunch - Launches the IPC server to listen to communications</li>
<li>InstrumLauch - Launches the instrumentation for a selected project</li>
</ol>
<p>Below are the steps to be followed to run the project:</p>
<ol>
<li>Run the file <code>ServerLauch.scala</code>. This should start a server at <code>127.0.0.1:8080</code>. Make sure that this port is free<br>
or else the server won’t start. This file should be run first and has to be started only once for running any number of<br>
instrumentations. Donot close the terminal window in which this file is run</li>
<li>Run the file <code>InstrumLaunch.scala</code> to run the instrumentation. You will be provided with a list of project configuration<br>
files available to the instrumenter. You can choose which project to run. Running the instrumenter for more than once on the<br>
same source file may cause unexpected results. This project already has a <code>Pathfinder</code> and <code>Matrix Rotation</code> program which<br>
can be used for test purposes.</li>
<li>After each run two timestamped files will be found in the <code>tracefiles</code> directory in the project root. The file with<br>
<code>binding_</code> will have the formatted data of the hashtable for each variable and <code>trace_</code> will have running data of each<br>
instrum statement executed.</li>
</ol>
<p><code>sbt</code> command line can also be used to run the project. Running the project from the root will provide you with option to<br>
select which class has to run. Run both the files in two separate terminals in the order described above.</p>
<h3 id="what-instrumlaunch-does-apart-from-instrumentation">What InstrumLaunch does apart from instrumentation</h3>
<ol>
<li>Before any instrumentation starts all java files in <code>src</code> folder are copied to a folder name <code>oldSrc</code> one level above <code>src</code>, thus<br>
saving the files which can be reused again for instrumenting.</li>
<li><code>TemplateClass.java</code> and <code>AP.java</code> are two files that is needed by the instrumented program to log the statements and also<br>
to communicate back to the launcher program. These files are not instrumented and a copy is kept in <code>config/astparser</code>. Once the<br>
isntrumentation is done and before launching JVM instance the entire <code>config/astparser</code> is copied into the source folder of instrumented<br>
program. Also a new import <code>import astparser.*</code> is added to all instrumented java files for resolving dependencies.</li>
<li>To enable the use of Websockets and JSON, two jars needs <code>nv-websocket-client-2.9.jar</code> and <code>json-20190722.jar</code> needs to be present in the <code>jars</code> folder of the instrumented<br>
project. This is copied from <code>config/dependencyjar</code>.</li>
</ol>
<h3 id="how-to-add-a-new-project-for-instrumentation">How to add a new project for instrumentation</h3>
<p>Each project used is based on Ant build. Ant is used for its simplicity to bootstrap a new project<br>
quickly. Any tool build which gives out <code>.class</code> files as output can be swapped out instead of Any. Since using Ant<br>
each project is expected to have a <code>build.xml</code> file with the below specification:</p>
<ol>
<li>
<p>Default target is <code>compile</code></p>
</li>
<li>
<p>A <code>javac</code> node is defined with the <code>destdir</code> property set to a folder.</p>
</li>
<li>
<p>Two dependency jars as defined below are specified in the classpath node. Only declaration for the <code>jars</code> in the build<br>
file is needed. The original files are copied automatically by the launcher program.</p>
<pre class=" language-xml"><code class="prism  language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>pathelement</span> <span class="token attr-name">path</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>&lt;your_jar_folder&gt;/nv-websocket-client-2.9.jar<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>			
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>pathelement</span> <span class="token attr-name">path</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>&lt;your_jar_folder&gt;/json-20190722.jar<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span> 
</code></pre>
</li>
</ol>
<p>Below is an example of a <code>build.xml</code> which can be used as a starting point</p>
<pre class=" language-xml"><code class="prism  language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project</span> <span class="token attr-name">default</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>compile<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>target</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>compile<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mkdir</span> <span class="token attr-name">dir</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>target<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>javac</span> <span class="token attr-name">srcdir</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>src<span class="token punctuation">"</span></span> <span class="token attr-name">destdir</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>target<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>
		<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>classpath</span><span class="token punctuation">&gt;</span></span>
		    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>pathelement</span> <span class="token attr-name">path</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>jars/stdlib(3).jar<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>
		    <span class="token comment">&lt;!--Below two lines are included as per specification--&gt;</span>
		    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>pathelement</span> <span class="token attr-name">path</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>jars/nv-websocket-client-2.9.jar<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>			
			<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>pathelement</span> <span class="token attr-name">path</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>jars/json-20190722.jar<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span> 
			
	    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>classpath</span><span class="token punctuation">&gt;</span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>javac</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>target</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project</span><span class="token punctuation">&gt;</span></span>
</code></pre>
<p>To add a new project for instrumentation perform the below steps:</p>
<ol>
<li>
<p>Make sure your project is Ant buildable.</p>
</li>
<li>
<p>Add a configuration file to the folder <code>config/instrum</code>. This a configuration file and should have the extension <code>.conf</code>.<br>
Each parameter in the configuration file is shown below: All parameters are mandatory and the program cannot procced without<br>
setting each of the below parameters</p>
<ol>
<li>rootRelativetoInstrumDir - Set this to <code>true</code> if the new project foler is saved inside the instrumentation project<br>
directory. Else set this to <code>false</code>.</li>
<li>root - Specify path to the root of your project. If you set <code>true</code> for <code>rootRelativetoInstrumDir</code> this path should be<br>
relative else you need an absolute path to be specified.</li>
<li>srcDir - Specify path to top level directory which has <code>.java</code> code files. This is to be set relatively to the <code>root</code><br>
parameter</li>
<li>targetDir - Specify where to find the <code>.class</code> files produced by the Ant builder. This is to be set relatively to the <code>root</code><br>
parameter</li>
<li>jarFolder - Specify the folder where your <code>jars</code> are saved. This should be the folder part of your <code>classpath</code> specification<br>
in the <code>build.xml</code>. This is to be set relatively to the <code>root</code> parameter.</li>
<li>buildFile - Specify where your <code>build.xml</code> file is. This is to be set relatively to the <code>root</code> parameter.</li>
<li>mainClass - Give the qualified name including the package structure of your main class</li>
<li>arguments - This is a list of list. The inner list is separated by commas and each inner list consists of the arguments<br>
to be passed to the instrumented program.</li>
</ol>
<p>See for a sample <code>pathfinder.conf</code> file for a project saved inside the instrumentation project in the path <code>projects/project1</code></p>
<pre class=" language-editorconfig"><code class="prism  language-editorconfig">compile{
  # Set this to true if the project root directory
  # is inside the instrum project directory and the provide
  # relative path to the project folder
  rootRelativetoInstrumDir = true
  root = "projects/project1"
  # Everything below this line is relative to the
  # project root
  srcDir = "src"
  targetDir = "target"
  jarFolder = "jars"
  buildFile = "build.xml"
}

run {
  # Provide the qualified main class
  mainClass = "PathFindingOnSquaredGrid"
  # Provide input parameters
  arguments = [
    [10 0.3 0 0 9 9]
  ]
}
</code></pre>
<p>See for a sample <code>pathfinder.conf</code> file for a project saved at <code>/home/sherryl/Desktop/project1</code></p>
<pre class=" language-editorconfig"><code class="prism  language-editorconfig">compile{
  # Set this to true if the project root directory
  # is inside the instrum project directory and the provide
  # relative path to the project folder
  rootRelativetoInstrumDir = false
  root = "/home/sherryl/Desktop/project1"
  # Everything below this line is relative to the
  # project root
  srcDir = "src"
  targetDir = "target"
  jarFolder = "jars"
  buildFile = "build.xml"
}

run {
  # Provide the qualified main class
  mainClass = "PathFindingOnSquaredGrid"
  # Provide input parameters
  arguments = [
    [10 0.3 0 0 9 9]
  ]
}
</code></pre>
</li>
<li>
<p>Make sure the project is in the path you specified as <code>root</code> and you are good to run the code.</p>
</li>
</ol>
<h5 id="basic-troubleshooting">Basic Troubleshooting</h5>
<ol>
<li>This project needs port <code>8080</code> to be free to run. If you get an <code>Address already in use</code> make sure to free the port.<br>
For a Unix system you can run the command <code>sudo lsof -i:8080</code> and then kill the PID blocking the port.</li>
<li>If you get a <code>Failed to connect to 'localhost:8080'</code> error when running the <code>InstrumLaunch</code> make sure you have run<br>
<code>ServerLaunch</code> and the same is running.</li>
</ol>
<h2 id="technical-design">Technical Design</h2>
<p>Below is the overall architecture of the Instrumenter system and overview of all components:<br>
<img src="https://i.ibb.co/MS9KZyN/architecture.jpg" alt="enter image description here"></p>
<h2 id="components-overview">Components Overview</h2>
<h4 id="the-launcher-program">The Launcher Program</h4>
<p>Launcher program is divided into two:</p>
<h5 id="instrumentor--jvmlauncher">1. Instrumentor &amp; JVMLauncher</h5>
<p>This component deals with reading files in a JAVA project, instrumenting the code and launch JVM instances for each set<br>
of input. Main components are:</p>
<ul>
<li>Parser : Parser will run over the code and rewrites certain control structures which has single statements to blocks.</li>
<li>Instrumentor : Visitors are used to visitor over predefined statements and expressions, find their names, binding in<br>
the current scope and value currently held. The values found are then passed to <code>TemplateClass.instrum()</code> method for<br>
being sent to the launcher program.</li>
<li>AntBuilder : Ant is used as the build tool. Each project passed should have a <code>build</code> file. Ant is used for its simplicity.<br>
Ant can be swapped out for any other build tool. The output of this step is <code>.class</code> files and that’s all is needed from<br>
this step. The <code>.class</code> files will be saved into a predefined folder.</li>
<li>JVMLauncher : JDI is used to launch separate instances of JVM for each set of inputs in the selected project</li>
</ul>
<h5 id="ipc-server--trace-writer">2. IPC Server &amp; Trace Writer</h5>
<p>This component has two main functions</p>
<ul>
<li>IPC Server - This server needs to be started before the instrumenter is run. Server listens to <code>127.0.0.1:8080</code> for<br>
incoming messages. Each message is in JSON format in the below schema:</li>
</ul>
<pre class=" language-json"><code class="prism  language-json"><span class="token punctuation">{</span>
  <span class="token string">"line"</span><span class="token punctuation">:</span> <span class="token string">"Int"</span><span class="token punctuation">,</span>
  <span class="token string">"statementType"</span><span class="token punctuation">:</span> <span class="token string">"String"</span><span class="token punctuation">,</span>
  <span class="token string">"data"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token string">"type"</span><span class="token punctuation">:</span>  <span class="token string">"String"</span><span class="token punctuation">,</span> <span class="token string">"binding"</span><span class="token punctuation">:</span> <span class="token string">"String"</span><span class="token punctuation">,</span> <span class="token string">"value"</span><span class="token punctuation">:</span>  <span class="token string">"String"</span><span class="token punctuation">}</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Each JSON thus obtained is parsed and a hastable is maintained with the unique identifier as <code>binding</code>. And the JSON is<br>
saved. Also a running trace is maintained to store the unprocessed JSON data which comes from the JVM instance.<br>
A hashtable and trace maintained for each connected client and the data is moved to timestamp named text file when each<br>
client is disconnected.</p>
<ul>
<li>JSON Parser &amp; File Writer : Has code to parse each JSON coming to the system and write files at the disconnection of<br>
each client.</li>
</ul>
<h4 id="the-jvm-instance-client">The JVM Instance (Client)</h4>
<p>Each project is passed to a JVM instace. The instrumented code has two main components:</p>
<ul>
<li>Original Code with Instrumentation statements added and each instrumented statement will be of the form<br>
<code>TemplateClass.instrum(int line, String typeofStatement, AP... parameters)</code>.</li>
<li>A <code>TemplateClass</code> with static members. When the static class is initialized a unique web socket connection is made<br>
to the launcher program. This connection will be used for IPC. Every <code>instrum</code> method executed will send a JSON payload<br>
to the launcher program for processing and saving.</li>
</ul>
<h2 id="component-details">Component Details</h2>
<h4 id="the-launcher-program-1">1. The Launcher Program</h4>
<h5 id="ast-parsing-and-instrumentation--">AST Parsing and Instrumentation -</h5>
<p>The parsing and instrumentation is done in multiple steps.</p>
<ol>
<li>AST Parsing
<ol>
<li>Block Rewrite</li>
<li>Code Rewrite</li>
</ol>
</li>
<li>Instrumentation</li>
</ol>
<h6 id="ast-parsing--">1. AST Parsing -</h6>
<p>This consists of Block rewriting and code rewriting. This is done as a first step to transform the code, before we begin instrumentation. This is handled in files<br>
BlockConverter, DoStatementCon, ForStatementCon, WhileStatementCon and FinalConverter classes under the converters module.</p>
<h6 id="i.-block-rewrite">i. Block Rewrite</h6>
<p>As part of block rewrite step, all singled statements inside control structures , are converted to blocks.</p>
<p>This is done for all control statements including, <em>for</em>, <em>do-while</em>, <em>while</em>, <em>for-each</em>, <em>if-else if-else</em>.<br>
This is done to ensure that when we need to add an additional logging statement, we do not need to handle the absence of blocks.</p>
<p><em>Example</em> -</p>
<pre><code>int i = 3;
if(i &lt; 2)
    System.out.println("hello");
else
    System.out.println("hi"); 
</code></pre>
<p>is transformed to</p>
<pre><code>int i = 3;
if(i &lt; 2) {
System.out.println("hello");
}
else {
System.out.println("hi");
}
</code></pre>
<h6 id="ii.-code-rewrite">ii. Code Rewrite</h6>
<p>In the code rewrite step, we transform the method invocations in the expressions in looping constructs, <em>for</em>, <em>while</em> and <em>do-while</em> into<br>
single assignments.</p>
<p>This is only  done for simple infix expressions with a single method invocation on either side of the operand; i.e. statements of the below nature, are not handled.</p>
<pre><code>while(x() + x() + x() &lt; 10) 
</code></pre>
<p>But for simple expressions involving one method invocation, we account for nested loops as well.</p>
<p><em>Example</em> -</p>
<pre><code>while(x() &lt; 5) {
    do {
        System.out.println("Hi");
    } while(x()&lt; 2);
}

int x() {
    return 2; 
}
</code></pre>
<p>is transformed to</p>
<pre><code>int wh1 = x();
while(wh1 &lt; 5) {
    int do1 = 0;
    do {   
        System.out.println(i);
        do1 = x();
    } while(do1 &lt; 2);
    wh1 = x();
}

int x() {
    return 2; 
}
</code></pre>
<p>In addition to the loop construct transformation, we also add imports to include the Template class package (<em>This class includes the instrumentation method that is inserted into the original source</em>) and an additional last statement in the main() method to disconnect<br>
the socket (<em>This is part of the IPC to communicate back with the launcher program</em>).</p>
<h6 id="instrumentation">2. Instrumentation</h6>
<p>Instrumentation is added to capture the variables, the bindings and their values in a Java source program. As part of this implementation, we handle the following constructs through visitors.<br>
The visitors are under the visitors module and the instrumentation is done in Instrum, AssignmentInstrum, ControlInstrum, MethodDeclarationInstrum, ReturnInstrum and VDSInstrum classes under the instrumentation module.</p>
<h6 id="constructs-handled">Constructs Handled</h6>
<ol>
<li>
<p>Control structures - <em>for</em>, <em>while</em>, <em>do-while</em>, <em>for-each</em>, <em>if-else-if-else</em>, <em>switch</em></p>
<p><em>Sample statement</em> -</p>
<pre><code>for(int i=0; i &lt; 10 ; i++) {
    /*Do something here.*/
}
</code></pre>
<p><em>Instrumentation Statement inserted</em> -</p>
<pre><code>for (int x = 0; x &lt; matrix.length; x++) 
TemplateClass.instrum(39, "ForStatement", new AP("SimpleName", "PathFindingOnSquaredGrid.generateHValue(boolean[][], int, int, int, int, int, int, int, boolean, int).x", x), new AP("QualifiedName", "length", matrix.length));
</code></pre>
<p><em>Resulting trace with details of Location, Statement type, Binding and variable value</em> -</p>
<pre><code>Line: 39, SeenAt: "ForStatement"
Name: "PathFindingOnSquaredGrid.generateHValue(boolean[][], int, int, int, int, int, int, int, boolean, int).x", Type: "SimpleName", Value: "6"
Name: "()", Type: "QualifiedName", Value: "10"
</code></pre>
</li>
<li>
<p>Return statements - Return statements at the end of a function call.</p>
<p><em>Sample statement</em> -</p>
<pre class=" language-java"><code class="prism  language-java"><span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span> 
</code></pre>
<p><em>Instrumentation Statement inserted</em> -</p>
<pre><code>return a;
TemplateClass.instrum(21, "ReturnStatement", new AP("SimpleName", "PathFindingOnSquaredGrid.random(int, double).a", a));
</code></pre>
<p><em>Resulting trace with details of Location, Statement type, Binding and variable value</em> -</p>
<pre><code>Line: 21, SeenAt: "ReturnStatement"
Name: "PathFindingOnSquaredGrid.random(int, double).a", Type: "SimpleName", Value: "[[Z@27c20538"
</code></pre>
</li>
<li>
<p>Method Declarations - All method declarations along with the parameters in the method signatures. We only call out the formal parameters along with their bindings and values in the trace. The bindings include the name of the method themselves.<br>
<em>Sample statement</em> -</p>
<pre><code> public static void main(String[] args) {
     /* Do something here */
 }
</code></pre>
<p><em>Instrumentation Statement inserted</em> -</p>
<pre><code>public static void main(String[] args) 
TemplateClass.instrum(389, "MethodDeclaration", new AP("SimpleName", "PathFindingOnSquaredGrid.main(String[]).args", args));
</code></pre>
<p><em>Resulting trace with details of Location, Statement type, Binding and variable value</em> -</p>
<pre><code>Line: 389, SeenAt: "MethodDeclaration"
Name: "PathFindingOnSquaredGrid.main(String[]).args", Type: "SimpleName", Value: "[Ljava.lang.String;@311d617d"
</code></pre>
</li>
<li>
<p>Variable Declaration Statements - All variable declaration statements, including multiple declarations with initializers.</p>
<p><em>Sample statement</em> -</p>
<pre><code>int i = 0;
int i,j;
int i = 0, j = 0;
</code></pre>
<p><em>Instrumentation Statement inserted</em> -</p>
<pre><code>gridSize = Integer.parseInt(args[0]);
TemplateClass.instrum(393, "VariableDeclaration", new AP("SimpleName", "PathFindingOnSquaredGrid.main(String[]).gridSize", gridSize), new AP("MethodInvocation", "Integer.parseInt(String)", ""), new AP("inner SimpleName", "PathFindingOnSquaredGrid.main(String[]).args", args), new AP(" inner NumberLiteral", "", 0));
</code></pre>
<p><em>Resulting trace with details of Location, Statement type, Binding and variable value</em> -</p>
<pre><code>Line: 393, SeenAt: "VariableDeclaration"
Name: "PathFindingOnSquaredGrid.main(String[]).gridSize", Type: "SimpleName", Value: "10"
Name: "Integer.parseInt(String)", Type: "MethodInvocation", Value: ""
Name: "PathFindingOnSquaredGrid.main(String[]).args", Type: "inner SimpleName", Value: "[Ljava.lang.String;@311d617d"
Name: "", Type: " inner NumberLiteral", Value: "0"

// This translates to gridSize = Integer.parseInt(args[0]). inner SimpleName is a type that is used to signify array access. 
</code></pre>
</li>
<li>
<p>Expression statements - We handle instrumentation of a lot of expression statement constructs as provided by the Java language. Below is a list of constructs that we handle in our instrumentation.<br>
<em>Sample Statements</em> -</p>
<pre><code>i = x();                     //Assignment (with a method invocation).
i = i++;                     //Assignment (postfix expression).
i = -2;                      //Assignment (prefix expression).
i = x() + 2;                 //Assignment (infix expression).
cell[y][x] = new Node(y, x); //Class Instance creation.
cell[y] = Node.y             //Field Access.
if (node == cell[Bi][Bj])    //Array access.
cell[0][1] = 2;              //Array initialization.
</code></pre>
<p><em>Sample Instrumentation Statement inserted</em> -</p>
<pre><code>cell[y][x] = new Node(y, x);
TemplateClass.instrum(41, "Assign", new AP("Array Begin", "", "{"), new AP("inner SimpleName", "PathFindingOnSquaredGrid.cell", cell), new AP(" inner SimpleName", "PathFindingOnSquaredGrid.generateHValue(boolean[][], int, int, int, int, int, int, int, boolean, int).y", y), new AP(" inner SimpleName", "PathFindingOnSquaredGrid.generateHValue(boolean[][], int, int, int, int, int, int, int, boolean, int).x", x), new AP("Array End", "", "}"), new AP("ClassInstanceCreation", "Node", "Node.Node(int, int)"), new AP("SimpleName", "PathFindingOnSquaredGrid.generateHValue(boolean[][], int, int, int, int, int, int, int, boolean, int).y", y), new AP("SimpleName", "PathFindingOnSquaredGrid.generateHValue(boolean[][], int, int, int, int, int, int, int, boolean, int).x", x));
</code></pre>
<p><em>Resulting trace with details of Location, Statement type, Binding and variable value</em> -</p>
<pre><code>Line: 41, SeenAt: "Assign"
Name: "", Type: "Array Begin", Value: "{"
Name: "PathFindingOnSquaredGrid.cell", Type: "inner SimpleName", Value: "[[LNode;@72d818d1"
Name: "PathFindingOnSquaredGrid.generateHValue(boolean[][], int, int, int, int, int, int, int, boolean, int).y", Type: " inner SimpleName", Value: "0"
Name: "PathFindingOnSquaredGrid.generateHValue(boolean[][], int, int, int, int, int, int, int, boolean, int).x", Type: " inner SimpleName", Value: "0"
Name: "", Type: "Array End", Value: "}"
Name: "Node", Type: "ClassInstanceCreation", Value: "Node.Node(int, int)"
Name: "PathFindingOnSquaredGrid.generateHValue(boolean[][], int, int, int, int, int, int, int, boolean, int).y", Type: "SimpleName", Value: "0"
Name: "PathFindingOnSquaredGrid.generateHValue(boolean[][], int, int, int, int, int, int, int, boolean, int).x", Type: "SimpleName", Value: "0"

This shows that an array is assigned a value new Node(y,x) 
</code></pre>
</li>
</ol>
<h5 id="compilation--execution-jvm-launcher">Compilation &amp; Execution (JVM Launcher)</h5>
<p>The launcher program is responsible for compiling and executing multiple instances of the client application (JVM instances) against multiple inputs.<br>
This also receives IPC messages through the web socket server and stores them in a hash table. This is then dumped into files, which are available for viewing.<br>
The launcher comprises of multiple components -</p>
<p>######1. The ANT builder -<br>
This is responsible for compiling the source application (client), after adding instrumentation statements and generate <code>.class</code> files.</p>
<p>The driver method in the AntBuilder class, under the launcher module is <code>compileAndLaunchJVM()</code>. This reads the <code>build.xml</code> config file from the source application<br>
and builds the application.</p>
<p>We use the <code>buildFinished()</code> hook to determine if the build completed successfully and launch the JVM from this method.</p>
<p>On build failure, we log the error messages and abort as we cannot proceed further with execution.</p>
<p>######2. The JVM launcher -<br>
The <code>executeJava()</code> method under the AntBuilder class is responsible for invoking the JVM by reading the run configuration parameters. This method<br>
runs a JVM instance for every parameter as mentioned in the <code>run.arguments</code> in the project configuration file.</p>
<p>The JVM is initialized with details of the Main class, program arguments, class path and any dependent jars and started. This is done in the JVMLauncher class<br>
under the launcher module.</p>
<p>When, the JVM launch fails, we print the error and continue execution for the next set of inputs.</p>
<h4 id="ipc-server">IPC Server</h4>
<p>Files: <code>WSServer.scala</code> and <code>BindingData.scala</code><br>
To enable IPC communication between the launcher program and JVM instances running code a <code>akka-websocket</code> connection is used.<br>
Each new JVM instance requested connects to the server as a new client. The sever listens to <code>127.0.0.1:8000/instrumserver</code> for<br>
data from the clients. The data accepted is JSON format.</p>
<p>The server is responsible for building the hashtable and keeping a trace of all the instrumentation data received.  This means<br>
that each client needs to keep its own copy of the hastable and the trace. For this purpose <code>akka-actor</code> is used as a sink<br>
for each client. A new actor instance will be created for each client and separate hastable and trace are maintained. <code>InstrumActor</code><br>
object is used to keep a track of the various events that occur during the communication starting from <code>Init</code> till <code>Completed</code>.</p>
<p>The <code>Flow</code> used groups the incoming data, and passes it to the method <code>parseJSONMessage(jsonString: String)</code> to parse each<br>
JSON object obtained. <code>BindingData</code> class is used to de-serialize the JSON and provide convenience methods of easy printing.<br>
During parsing each JSON is saved to the hashtable using <code>binding</code> of each variable as the unique identifier.<br>
Also the original JSON is  saved to variable to be written to a tracefile later.</p>
<p>Method <code>writeData()</code> will be invoked when a client disconnects, ie. the JVM instance has finished execution of all the statements<br>
in the code. At this point the hashtable and trace data is written into <code>.txt</code> files and saved in the folder <code>tracefiles</code>. Each file<br>
will be time stamped. Hashtable data has the prefix <code>binding_</code> and trace data has the prefix <code>trace</code>.</p>
<p>The main class in <code>ServerLaunch</code> is used to invoke the server. Not that there is no need to start the server every time a new instrumentation<br>
is done. It would be enough to make sure that the server is still running at all time that the instrumenter is used.</p>
<h4 id="trace-writer">Trace writer</h4>
<p>This writes trace and binding files under <code>tracefiles</code> folder.</p>
<h4 id="the-jvm-instance-client-1">The JVM Instance (Client)</h4>
<p>This consists of the modified source with instrumented statements.</p>
<h6 id="template-class">Template Class</h6>
<p>This is a static java class that holds the <code>instrum()</code> method. Logging statements are added in the source application (client), which are invocations of this method.</p>
<ul>
<li><code>instrum(int lineNumber, String typeOfStatement, AP... args)</code>  - This method takes in a line number, type of statement and a set of arguments with details on the variables used in that statement.<br>
A JSON object is constructed and sent back to the launcher program through a web socket.</li>
<li><code>WebSocket connect()</code> - This method is invoked when the TemplateClass is initialized, during the very first invocation of <code>instrum()</code>. This initializes a web socket to send messages to the launcher program.</li>
<li><code>finalizeInstrum()</code> - This method is invoked prior to exiting the client application (the last statement in <code>main()</code>). This method disconnects the socket.</li>
</ul>
<h6 id="ap-class">AP Class</h6>
<p>Multiple instances of the AP class are passed as arguments to the <code>instrum()</code> method. This holds information about variables including the type, binding and the value of the variable, for every variable used in a statement.<br>
Below is the structure of the AP class.</p>
<pre class=" language-public"><code class="prism  language-public">    String type;
    String name;
    String value;
</code></pre>
<h4 id="results-trace--binding-files">Results (Trace &amp; Binding Files)</h4>
<p>When execution completes, two files are created per execution instance (per input) and are stored under <code>tracefiles</code> folder.<br>
The two files are created with names <code>trace_&lt;timestamp&gt;</code> and <code>bindings_&lt;timestamp&gt;</code>.</p>
<p>The files have the below content and structure.</p>
<ul>
<li>Trace -<br>
This file gives detailed information of the type of statement, the line number and the various components included in the statement with their values.</li>
</ul>
<pre><code>Line: 394, SeenAt: "VariableDeclaration"
Name: "PathFindingOnSquaredGrid.main(String[]).probability", Type: "SimpleName", Value: "0.3"
Name: "Double.Double.parseDouble(String)", Type: "MethodInvocation", Value: ""
Name: "PathFindingOnSquaredGrid.main(String[]).args", Type: "inner SimpleName", Value: "[Ljava.lang.String;@311d617d"
Name: "", Type: " inner NumberLiteral", Value: "1".
========
Line: 16, SeenAt: "ForStatement"
Name: "PathFindingOnSquaredGrid.random(int, double).i", Type: "SimpleName", Value: "0"
Name: "PathFindingOnSquaredGrid.random(int, double).N", Type: "SimpleName", Value: "10"
========
Line: 401, SeenAt: "MethodInvocation"
Name: "PathFindingOnSquaredGrid.menu(int, double, int, int, int, int)", Type: "MethodInvocation", Value: ""
Name: "PathFindingOnSquaredGrid.main(String[]).gridSize", Type: "args SimpleName", Value: "10"
Name: "PathFindingOnSquaredGrid.main(String[]).probability", Type: "args SimpleName", Value: "0.3"
Name: "PathFindingOnSquaredGrid.main(String[]).y1", Type: "args SimpleName", Value: "0"
Name: "PathFindingOnSquaredGrid.main(String[]).x1", Type: "args SimpleName", Value: "0"
Name: "PathFindingOnSquaredGrid.main(String[]).y2", Type: "args SimpleName", Value: "0"
Name: "PathFindingOnSquaredGrid.main(String[]).x2", Type: "args SimpleName", Value: "0"
========
</code></pre>
<ul>
<li>Bindings -<br>
This file mentions all instances of where a variable is used, with details of its binding, type, value , location of occurence and the type of statement it is used in.</li>
</ul>
<pre><code>========= "PathFindingOnSquaredGrid.menu(int, double, int, int, int, int).n" =========
Name: "PathFindingOnSquaredGrid.menu(int, double, int, int, int, int).n", Type: "SimpleName", Value: "10", Line: 69, seenAt: "MethodDeclaration"
Name: "PathFindingOnSquaredGrid.menu(int, double, int, int, int, int).n", Type: "args SimpleName", Value: "10", Line: 73, seenAt: "VariableDeclaration"
Name: "PathFindingOnSquaredGrid.menu(int, double, int, int, int, int).n", Type: "args SimpleName", Value: "10", Line: 86, seenAt: "MethodInvocation"
Name: "PathFindingOnSquaredGrid.menu(int, double, int, int, int, int).n", Type: "args SimpleName", Value: "10", Line: 118, seenAt: "MethodInvocation"
Name: "PathFindingOnSquaredGrid.menu(int, double, int, int, int, int).n", Type: "args SimpleName", Value: "10", Line: 143, seenAt: "MethodInvocation"

========= "PathFindingOnSquaredGrid.main(String[]).y1" =========
Name: "PathFindingOnSquaredGrid.main(String[]).y1", Type: "SimpleName", Value: "0", Line: 396, seenAt: "VariableDeclaration"
Name: "PathFindingOnSquaredGrid.main(String[]).y1", Type: "args SimpleName", Value: "0", Line: 400, seenAt: "MethodInvocation"
Name: "PathFindingOnSquaredGrid.main(String[]).y1", Type: "args SimpleName", Value: "0", Line: 401, seenAt: "MethodInvocation"
</code></pre>
<p>ServerLaunch Output</p>
<pre class=" language-undefined"><code class="prism language-*************************************************************************************************************** language-undefined">                                         Java Instrumentation Server
***************************************************************************************************************
Keep this server running until your use of Instrumentation is done
Server runs at 127.0.0.1:8080

***************************************************************************************************************

Server online at http://localhost:8080/
Press RETURN to stop...
WebSocket terminated
</code></pre>
<p>InstrumLaunch Output (truncated). Run on <code>projects/project2</code></p>
<pre><code>***************************************************************************************************************
                                         Java Instrumentation Application
***************************************************************************************************************
Choose a config file from below to run the instrumentation

To add a new project to the list add a new .conf file to the resources/projectConf folder with details as
specified in the documentation

***************************************************************************************************************

1: pathfinder.conf
2: rotatematrix.conf
0: Exit
2
Detected Java version: 11 in: /usr/lib/jvm/java-11-openjdk-amd64
Detected OS: Linux
parsing buildfile /media/01D3908E9C0056A0/code/IdeaProjects/sherryl_mathewgeorge_courseproject/projects/project2/build.xml with URI = file:/media/01D3908E9C0056A0/code/IdeaProjects/sherryl_mathewgeorge_courseproject/projects/project2/build.xml
Project base dir set to: /media/01D3908E9C0056A0/code/IdeaProjects/sherryl_mathewgeorge_courseproject/projects/project2
Build sequence for target(s) `compile' is [compile]
Complete build sequence is [compile, ]

compile:
parsing buildfile jar:file:/home/sherryl/.cache/coursier/v1/https/repo1.maven.org/maven2/org/apache/ant/ant/1.10.7/ant-1.10.7.jar!/org/apache/tools/ant/antlib.xml with URI = jar:file:/home/sherryl/.cache/coursier/v1/https/repo1.maven.org/maven2/org/apache/ant/ant/1.10.7/ant-1.10.7.jar!/org/apache/tools/ant/antlib.xml from a zip file
    [mkdir] Created dir: /media/01D3908E9C0056A0/code/IdeaProjects/sherryl_mathewgeorge_courseproject/projects/project2/target
    [javac] /media/01D3908E9C0056A0/code/IdeaProjects/sherryl_mathewgeorge_courseproject/projects/project2/build.xml:4: warning: 'includeantruntime' was not set, defaulting to build.sysclasspath=last; set to false for repeatable builds
    [javac] astparser/AP.java added as astparser/AP.class doesn't exist.
    [javac] astparser/TemplateClass.java added as astparser/TemplateClass.class doesn't exist.
    [javac] com/uic/edu/App.java added as com/uic/edu/App.class doesn't exist.
    [javac] Compiling 3 source files to /media/01D3908E9C0056A0/code/IdeaProjects/sherryl_mathewgeorge_courseproject/projects/project2/target
    [javac] Using modern compiler
    [javac] Compilation arguments:
    [javac] '-d'
    [javac] '/media/01D3908E9C0056A0/code/IdeaProjects/sherryl_mathewgeorge_courseproject/projects/project2/target'
    [javac] '-classpath'
    [javac] '/media/01D3908E9C0056A0/code/IdeaProjects/sherryl_mathewgeorge_courseproject/projects/project2/target:/media/01D3908E9C0056A0/code/IdeaProjects/sherryl_mathewgeorge_courseproject/projects/project2/jars/nv-websocket-client-2.9.jar:/media/01D3908E9C0056A0/code/IdeaProjects/sherryl_mathewgeorge_courseproject/projects/project2/jars/json-20190722.jar:/media/01D3908E9C0056A0/code/IdeaProjects/sherryl_mathewgeorge_courseproject/target/scala-2.13/classes:/home/sherryl/.cache/coursier/v1/https/repo1.maven.org/maven2/ch/qos/logback/logback-classic/1.2.3/logback-classic-1.2.3.jar:/home/sherryl/.cache/coursier/v1/https/repo1.maven.org/maven2/org/slf4j/slf4j-api/1.7.26/slf4j-api-1.7.26.jar:/home/sherryl/.cache/coursier/v1/https/repo1.maven.org/maven2/org/scala-lang/modules/scala-parser-combinators_2.13/1.1.2/scala-parser-combinators_2.13-1.1.2.jar:/home/sherryl/.cache/coursier/v1/https/repo1.maven.org/maven2/org/scala-lang/modules/scala-java8-compat_2.13/0.9.0/scala-java8-compat_2.13-0.9.0.jar:/home/sherryl/.cache/coursier/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-reflect/2.13.1/scala-reflect-2.13.1.jar:/home/sherryl/.cache/coursier/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.13.1/scala-library-2.13.1.jar:/home/sherryl/.cache/coursier/v1/https/repo1.maven.org/maven2/org/reactivestreams/reactive-streams/1.0.3/reactive-streams-1.0.3.jar:/home/sherryl/.cache/coursier/v1/https/repo1.maven.org/maven2/org/gnieh/logback-config/0.4.0/logback-config-0.4.0.jar:/home/sherryl/.cache/coursier/v1/https/repo1.maven.org/maven2/org/eclipse/platform/org.eclipse.text/3.9.0/org.eclipse.text-3.9.0.jar:/home/sherryl/.cache/coursier/v1/https/repo1.maven.org/maven2/org/eclipse/platform/org.eclipse.osgi/3.15.0/org.eclipse.osgi-3.15.0.jar:/home/sherryl/.cache/coursier/v1/https/repo1.maven.org/maven2/org/eclipse/platform/org.eclipse.equinox.registry/3.8.500/org.eclipse.equinox.registry-3.8.500.jar:/home/sherryl/.cache/coursier/v1/https/repo1.maven.org/maven2/org/eclipse/platform/org.eclipse.equinox.preferences/3.7.500/org.eclipse.equinox.preferences-3.7.500.jar:/home/sherryl/.cache/coursier/v1/https/repo1.maven.org/maven2/org/eclipse/platform/org.eclipse.equinox.common/3.10.500/org.eclipse.equinox.common-3.10.500.jar:/home/sherryl/.cache/coursier/v1/https/repo1.maven.org/maven2/org/eclipse/platform/org.eclipse.equinox.app/1.4.300/org.eclipse.equinox.app-1.4.300.jar:/home/sherryl/.cache/coursier/v1/https/repo1.maven.org/maven2/org/eclipse/platform/org.eclipse.core.runtime/3.16.0/org.eclipse.core.runtime-3.16.0.jar:/home/sherryl/.cache/coursier/v1/https/repo1.maven.org/maven2/org/eclipse/platform/org.eclipse.core.resources/3.13.500/org.eclipse.core.resources-3.13.500.jar:/home/sherryl/.cache/coursier/v1/https/repo1.maven.org/maven2/org/eclipse/platform/org.eclipse.core.jobs/3.10.500/org.eclipse.core.jobs-3.10.500.jar:/home/sherryl/.cache/coursier/v1/https/repo1.maven.org/maven2/org/eclipse/platform/org.eclipse.core.filesystem/1.7.500/org.eclipse.core.filesystem-1.7.500.jar:/home/sherryl/.cache/coursier/v1/https/repo1.maven.org/maven2/org/eclipse/platform/org.eclipse.core.expressions/3.6.500/org.eclipse.core.expressions-3.6.500.jar:/home/sherryl/.cache/coursier/v1/https/repo1.maven.org/maven2/org/eclipse/platform/org.eclipse.core.contenttype/3.7.400/org.eclipse.core.contenttype-3.7.400.jar:/home/sherryl/.cache/coursier/v1/https/repo1.maven.org/maven2/org/eclipse/platform/org.eclipse.core.commands/3.9.500/org.eclipse.core.commands-3.9.500.jar:/home/sherryl/.cache/coursier/v1/https/repo1.maven.org/maven2/org/eclipse/jdt/org.eclipse.jdt.core/3.19.0/org.eclipse.jdt.core-3.19.0.jar:/home/sherryl/.cache/coursier/v1/https/repo1.maven.org/maven2/org/apache/ant/ant-launcher/1.10.7/ant-launcher-1.10.7.jar:/home/sherryl/.cache/coursier/v1/https/repo1.maven.org/maven2/org/apache/ant/ant/1.10.7/ant-1.10.7.jar:/home/sherryl/.cache/coursier/v1/https/repo1.maven.org/maven2/joda-time/joda-time/2.10.5/joda-time-2.10.5.jar:/home/sherryl/.cache/coursier/v1/https/repo1.maven.org/maven2/commons-io/commons-io/2.6/commons-io-2.6.jar:/home/sherryl/.cache/coursier/v1/https/repo1.maven.org/maven2/com/typesafe/scala-logging/scala-logging_2.13/3.9.2/scala-logging_2.13-3.9.2.jar:/home/sherryl/.cache/coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/play-json_2.13/2.8.0/play-json_2.13-2.8.0.jar:/home/sherryl/.cache/coursier/v1/https/repo1.maven.org/maven2/com/typesafe/play/play-functional_2.13/2.8.0/play-functional_2.13-2.8.0.jar:/home/sherryl/.cache/coursier/v1/https/repo1.maven.org/maven2/com/typesafe/akka/akka-stream_2.13/2.6.0/akka-stream_2.13-2.6.0.jar:/home/sherryl/.cache/coursier/v1/https/repo1.maven.org/maven2/com/typesafe/akka/akka-protobuf-v3_2.13/2.6.0/akka-protobuf-v3_2.13-2.6.0.jar:/home/sherryl/.cache/coursier/v1/https/repo1.maven.org/maven2/com/typesafe/akka/akka-parsing_2.13/10.1.10/akka-parsing_2.13-10.1.10.jar:/home/sherryl/.cache/coursier/v1/https/repo1.maven.org/maven2/com/typesafe/akka/akka-http_2.13/10.1.10/akka-http_2.13-10.1.10.jar:/home/sherryl/.cache/coursier/v1/https/repo1.maven.org/maven2/com/typesafe/akka/akka-http-core_2.13/10.1.10/akka-http-core_2.13-10.1.10.jar:/home/sherryl/.cache/coursier/v1/https/repo1.maven.org/maven2/com/typesafe/akka/akka-actor_2.13/2.6.0/akka-actor_2.13-2.6.0.jar:/home/sherryl/.cache/coursier/v1/https/repo1.maven.org/maven2/com/typesafe/ssl-config-core_2.13/0.4.0/ssl-config-core_2.13-0.4.0.jar:/home/sherryl/.cache/coursier/v1/https/repo1.maven.org/maven2/com/typesafe/config/1.4.0/config-1.4.0.jar:/home/sherryl/.cache/coursier/v1/https/repo1.maven.org/maven2/com/google/protobuf/protobuf-java/3.10.0/protobuf-java-3.10.0.jar:/home/sherryl/.cache/coursier/v1/https/repo1.maven.org/maven2/com/fasterxml/jackson/datatype/jackson-datatype-jsr310/2.10.1/jackson-datatype-jsr310-2.10.1.jar:/home/sherryl/.cache/coursier/v1/https/repo1.maven.org/maven2/com/fasterxml/jackson/datatype/jackson-datatype-jdk8/2.10.1/jackson-datatype-jdk8-2.10.1.jar:/home/sherryl/.cache/coursier/v1/https/repo1.maven.org/maven2/com/fasterxml/jackson/core/jackson-databind/2.10.1/jackson-databind-2.10.1.jar:/home/sherryl/.cache/coursier/v1/https/repo1.maven.org/maven2/com/fasterxml/jackson/core/jackson-core/2.10.1/jackson-core-2.10.1.jar:/home/sherryl/.cache/coursier/v1/https/repo1.maven.org/maven2/com/fasterxml/jackson/core/jackson-annotations/2.10.1/jackson-annotations-2.10.1.jar:/home/sherryl/.cache/coursier/v1/https/repo1.maven.org/maven2/ch/qos/logback/logback-core/1.2.3/logback-core-1.2.3.jar'
    [javac] '-sourcepath'
    [javac] '/media/01D3908E9C0056A0/code/IdeaProjects/sherryl_mathewgeorge_courseproject/projects/project2/src'
    [javac] '-g:none'
    [javac] 
    [javac] The ' characters around the executable and arguments are
    [javac] not part of the command.
    [javac] Files to be compiled:
    [javac]     /media/01D3908E9C0056A0/code/IdeaProjects/sherryl_mathewgeorge_courseproject/projects/project2/src/astparser/AP.java
    [javac]     /media/01D3908E9C0056A0/code/IdeaProjects/sherryl_mathewgeorge_courseproject/projects/project2/src/astparser/TemplateClass.java
    [javac]     /media/01D3908E9C0056A0/code/IdeaProjects/sherryl_mathewgeorge_courseproject/projects/project2/src/com/uic/edu/App.java
BUILD FINISHED
{home=home=/usr/lib/jvm/java-11-openjdk-amd64, options=options=-classpath projects/project2/target:projects/project2/jars/json-20190722.jar:projects/project2/jars/nv-websocket-client-2.9.jar, main=main=com.uic.edu.App 3, suspend=suspend=true, quote=quote=", vmexec=vmexec=java}
[JDI: Sending Command(id=8) JDWP.EventRequest.Set]
[JDI: Sending:                 eventKind(byte): 6]
[JDI: Sending:                 suspendPolicy(byte): 2]
[JDI: Sending:                 modifiers(Modifier[]): ]
[JDI: Sending Command(id=10) JDWP.EventRequest.Set]
[JDI: Sending:                 eventKind(byte): 7]
[JDI: Sending:                 suspendPolicy(byte): 2]
[JDI: Sending:                 modifiers(Modifier[]): ]
[JDI: Sending Command(id=12) JDWP.VirtualMachine.Dispose]
[JDI: Target VM interface thread exiting]

Starting Matrix: 
 5 64 51
 50 81 36
 49 59 55

Rotated Matrix: 
 51 36 55
 64 81 59
 5 50 49


{home=home=/usr/lib/jvm/java-11-openjdk-amd64, options=options=-classpath projects/project2/target:projects/project2/jars/json-20190722.jar:projects/project2/jars/nv-websocket-client-2.9.jar, main=main=com.uic.edu.App 10, suspend=suspend=true, quote=quote=", vmexec=vmexec=java}
[JDI: Sending Command(id=21) JDWP.EventRequest.Set]
[JDI: Sending:                 eventKind(byte): 6]
[JDI: Sending:                 suspendPolicy(byte): 2]
[JDI: Sending:                 modifiers(Modifier[]): ]
[JDI: Sending Command(id=23) JDWP.EventRequest.Set]
[JDI: Sending:                 eventKind(byte): 7]
[JDI: Sending:                 suspendPolicy(byte): 2]
[JDI: Sending:                 modifiers(Modifier[]): ]
[JDI: Sending Command(id=25) JDWP.VirtualMachine.Dispose]
[JDI: Target VM interface thread exiting]
</code></pre>

    </div>
  </div>
</body>

</html>
